\section{Experimental Methods}
\label{sec:method}
Our goal is to find commits which fix a bug, along with the commits
which introduced that bug. First, we detect a bug-fixing commit $c$ by
searching the commit messages for common keywords such as ``fix'' and
``bug''. Next, we work backwards to locate the commits that introduced
the bug fixed in $c$. Using commit $c$ as a starting point, we compute
a diff for each file between the version after $c$ and the previous
version of that file, and record the line numbers changed in
$c$. Finally, we use the repository metadata to find the commit(s)
$c'$ which were responsible for the previous versions of the files
which were fixed, and we conclude that the commits $c'$ introduced the
bug.

Note that any change in $c$ which removes or modifies an existing line
of code is easy to attribute to a previous commit $c'$, since the
affected line of code existed in $c'$. However, a change in $c$ which
adds a new line of code has no corresponding change in any previous
revision, since this line did not previously exist. In that case, we
attribute responsibility to the commit which introduced the line just
before the new line.

\paragraph{Data collected}
Executing the above algorithm gives us data about each commit, as well
as the authors of the commits\footnote{Name/email.}.  We record the
following data for each commit: author, time, number of lines changed,
and number of times the commit introduced a bug later corrected. For
each author, we record the name, email(s), experience and
classification. We define the bug lifetime as the time from the
earliest commit which introduced a bug to the bug-fixing commit.

We compute an author's experience and classification based on the
frequency and duration of that author's commits to a project. Author
experience counts the time between an author's earliest and latest
commits. Author classification describes the author's most-common
frequency between consecutive commits: daily, weekly, monthly, and
single. Note that, for author classification purposes, we ignore
consecutive commits within 30 minutes of each other. As a sub-class of
the daily commiter classification, we also use a heuristic to identify
commiters who worked on the repository as part of their day job,
namely those for which 85\% of commits are between 8 AM and 4 PM
Monday to Friday.

% maybe move this to the results section
We only considered patches and bugs that are introduced after April 16th, 2005, when
the Linux kernel started to use Git, because the patches before this date do not have 
time information that is accurate to the hour.

\paragraph{Validation}
To validate our data we randomly sample commits then manually verify
that the commit is a bug-fix and that the correct commits introduced
the bug. We focus our manual efforts on changes which include
additions, as conceptually, they are the largest threat to validity.

% Currently there are no false negative rates, we probably have time to sample non fix commits

* time zone information



\paragraph{Threats to Validity}
While we believe that the commits from the examined software well represent commits in 
open source software, we do not intend to draw any general conclusions about
all software. 
Similar to any characteristic study, our
findings should be considered together with our evaluation methodology.

One caveat is that the commits are performed at different time zones as the studied software is 
developed distributed by many developers. If the recorded commit time is for one fixed time zone,
then the time information we collected is imprecise. For example, a Git recorded midnight may be afternoon
for the developer who made the commit. Fortunately, Git records all commits in the developers' local time 
together with the time zone information. Therefore, we used the local time of each commit to collect 
the data shown in this paper. 

As it takes some time for a buggy commit to be discovered, the recent commits that are buggy may not 
have been discovered yet, hence are missing in our statistics. However, as our data are collected over a long period time, 
we expect our data to be representative and the recent commits should exhibit similar characteristics as the rest of the commits. 

The commit time does not necessary correspond to the coding time of a commit. A developer may wait 
for a long time before they commit their code. Studying how coding time correlates with code quality remains as our future work. 


\note{The following code figures are good examples. We should reorganized and add them to the beginning of Section~\ref{sec:method}.
I would show and describe Listing 2 first, then Listing 3 (with time and author info added), and maybe finally Listing 1 (do we really need Listing 1?). 
You can use minipage in Latex or other drawing tools to combine all 3 listings into one nice figure.  - Lin}

We demonstrate our technique on a simple example, for instance say
there is a change in the code repository such as the one in Listing
\ref{lst-introduction}. The listings contain a {\em unified diff}
between the current version in the commit and the previous version,
which is what we use in our tool. The bug here is that when {\em i} is
equal to 256 the code should actually use the {\em do\_unicode}
function. A commit which fixes this bug is shown in Listing \ref{lst-fix}.


\begin{lstlisting}[caption=An example bug introduction,label=lst-introduction, frame=single]
Commit: f4ce718c...
Message: I hope this works.
@@ -100,0 +100,5 @@
+    if (i <= 256) {
+        do_ascii(i);
+    else {
+        do_unicode(i);
+    }
\end{lstlisting}

\begin{lstlisting}[caption=An example bug fix,label=lst-fix,frame=single]
Commit: 2cdc03fe...
Message: I fixed a bug!
@@ -100,1 +100,1 @@
-    if (i <= 256) {
+    if (i < 256) {
\end{lstlisting}

Our goal is to be able to find the commit which introduced the bug and
also link it to the commit which included the fix. We found most
developers indicate that their change is a fix by including the keyword "fix"
in the commit message. We perform a simple keyword search with the word "fix"
to find these commits. For this example we should find the commit
starting with 2cdc03fe. From the unified diff we know line 100 was
modified from the previous version on line 100. We then perform a {\em
  git-blame} on the previous version which indicates the last commit
which changed the line. The output of the blame is shown in Listing
\ref{lst-blame}

\begin{lstlisting}[caption=Blame of the previous version,label=lst-blame,frame=single]
f4ce718c...  100    if (i <= 256) {
\end{lstlisting}

Using the blame information we found the original commit which
introduced the bug, and can enter it into our database. This
technique of blaming can be used for any modifications or removals

