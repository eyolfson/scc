\section{Experimental Methods}
\label{sec:method}
Our goal is to find commits which report fixing a bug, as well as the commits
which introduced that bug. First, we detect a bug-fixing commit $c$ by
searching the commit messages for common keywords such as ``fix'' and
``bug''. Next, we work backwards to locate the commits that introduced
the bug fixed in $c$. Using commit $c$ as a starting point, we compute
a diff for each file between the version after $c$ and the previous
version of that file, and record the line numbers changed in
$c$. Finally, we use the repository metadata to find the commit(s)
$c'$ which were responsible for the previous versions of the files
which were fixed, and we conclude that the commits $c'$ introduced the
bug.

Note that any change in $c$ which removes or modifies an existing line
of code is easy to attribute to a previous commit $c'$, since the
affected line of code existed in $c'$. However, a change in $c$ which
adds a new line of code has no corresponding change in any previous
revision, since this line did not previously exist. In that case, we
attribute responsibility to the commit which introduced the line just
before the new line.

\paragraph{Data collected}
Executing the above algorithm gives us data about a number of commits
in the repository, as well as about the authors of these commits.  We
record the following data for each commit: author (as a name/email
pair), time, number of lines changed, and number of times the commit
introduced a bug later corrected. For each author, we record the name,
email(s), experience and classification. We define a bug lifetime's to
be the time from the earliest commit which introduced a bug to the
bug-fixing commit.

We compute an author's experience and classification based on the
frequency and duration of that author's commits to a project. Author
experience counts the time between an author's earliest and latest
commits to the project. Author classification describes the author's
most-common frequency between consecutive commits: daily, weekly,
monthly, and single. Note that, for author classification purposes, we
ignore consecutive commits within 30 minutes of each other. As a
sub-class of the daily commiter classification, we also use a
heuristic to identify commiters who worked on the repository as part
of their day job, namely those for which 85\% of commits are between 8
AM and 4 PM Monday to Friday.

\paragraph{Threats to Validity}
We describe a number of threats to validity: ....

A first threat to (construct) validity is that we must properly
identify bug-fixing and bug-introducing commits. To assess this
threat, we randomly sampled commits that our analysis identified to be
bug fixes, manually verified whether or not they were fixes, and
checked that we properly identified the commit that introduced the
bug. Most of the time in our manual verification was spent on changes
with additions, because we were most concerned about our somewhat
arbitrary attribution of responsibility to the line just before the
new line.

\note{How does that last line go together with the ``random sample'' bit? -PL}

% Currently there are no false negative rates, we probably have time to sample non fix commits

While we believe that the commits from the examined software well
represent commits in open source software, we do not intend to draw
any general conclusions about all software.  Like any other
characteristic study, our findings should be considered together with
our evaluation methodology.

We expect our methodology to properly account for developers in
different time zones. Git records each developer's local time (and
time zone) with a commit, thereby avoiding potential imprecisions in
our time-of-day results. We present all of our results in the local
time of the committer.

\note{We need to be sure that this is the case for all of the commits that
got imported from other source control systems also. -PL}

Because our methodology only identifies bugs which have later been
corrected, it will definitely omit recently-introduced bugs, as well
as longer-running bugs which have not yet been corrected. While this
implies that our results will omit some bugs, we do not believe that
this omission affects our validity, because there is no reason to
believe that there are important differences in the characteristics we
measure for fixed and unfixed bugs.

Finally, developers work on a patch over a (possibly-discontiguous)
time interval, but the code repository only records the endpoint of
that interval. The bug database may contain more information about the
starting point of the interval (e.g. it records when a bug is assigned
to a developer), but still does not capture any information about the
work patterns of the developer within the interval. There may be
correlations between the coding time (the width of the interval) and
code quality. We intend to investigate these issues in future work.


\note{The following code figures are good examples. We should reorganized and add them to the beginning of Section~\ref{sec:method}.
I would show and describe Listing 2 first, then Listing 3 (with time and author info added), and maybe finally Listing 1 (do we really need Listing 1?). 
You can use minipage in Latex or other drawing tools to combine all 3 listings into one nice figure.  - Lin}

\note{define bug-introduction time}


We demonstrate our technique on a simple example, for instance say
there is a change in the code repository such as the one in Listing
\ref{lst-introduction}. The listings contain a {\em unified diff}
between the current version in the commit and the previous version,
which is what we use in our tool. The bug here is that when {\em i} is
equal to 256 the code should actually use the {\em do\_unicode}
function. A commit which fixes this bug is shown in Listing \ref{lst-fix}.


\begin{lstlisting}[caption=An example bug introduction,label=lst-introduction, frame=single]
Commit: f4ce718c...
Message: I hope this works.
@@ -100,0 +100,5 @@
+    if (i <= 256) {
+        do_ascii(i);
+    else {
+        do_unicode(i);
+    }
\end{lstlisting}

\begin{lstlisting}[caption=An example bug fix,label=lst-fix,frame=single]
Commit: 2cdc03fe...
Message: I fixed a bug!
@@ -100,1 +100,1 @@
-    if (i <= 256) {
+    if (i < 256) {
\end{lstlisting}

Our goal is to be able to find the commit which introduced the bug and
also link it to the commit which included the fix. We found most
developers indicate that their change is a fix by including the keyword "fix"
in the commit message. We perform a simple keyword search with the word "fix"
to find these commits. For this example we should find the commit
starting with 2cdc03fe. From the unified diff we know line 100 was
modified from the previous version on line 100. We then perform a {\em
  git-blame} on the previous version which indicates the last commit
which changed the line. The output of the blame is shown in Listing
\ref{lst-blame}

\begin{lstlisting}[caption=Blame of the previous version,label=lst-blame,frame=single]
f4ce718c...  100    if (i <= 256) {
\end{lstlisting}

Using the blame information we found the original commit which
introduced the bug, and can enter it into our database. This
technique of blaming can be used for any modifications or removals

