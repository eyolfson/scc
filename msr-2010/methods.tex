\section{Experimental Methods}
\label{sec:method}
Our overall goal is to investigate the properties of ``buggy'', or
bug-introducing, commits. We define a \emph{bug-introducing} commit to be any
commit for which there exists a later \emph{bug-fixing} commit that purports to
fix the bug. A single bug-fixing commit may fix bugs introduced in
multiple bug-introducing commits. Note that, despite our terminology,
a bug-introducing commit is not necessarily bad code; it is possible 
that the later fix simply reflects a change in requirements or updates
the code to work with changes in third-party code.

Our methodology has three steps: 1) enumerating bug-fixing commits; 2)
identifying the lines changed in each bug-fixing commit; and 3)
finding the commits which were responsible for the previous (buggy)
version of each of the changed lines. We describe each of these steps
in more detail. First, to detect bug-fixing commits $c$, we searched
the commit messages for the keyword ``fix''. In our experience, most
developers indicate that a change is a fix by including the keyword
``fix'' in the commit message; Section~\ref{sec-results} explains how
we verified this intuition.  Next, we computed diffs for each file
changed in $c$ and recorded the line numbers $L_c$ which $c$
changed. Finally, we used the repository metadata (as implemented in
the ``git blame'' command) to identify the bug-introducing commits
$c'$ which changed the lines $L_c$.

\paragraph{Example} Listing~\ref{lst-fix} presents an example of a
bug-fixing commit. A commit consists of a commit id, which is a hash
of the commit's contents, represented as a hexadecimal number\footnote{Following common practice, because we can uniquely identify the commit by the first 8 digits of its commit id, we omit the other digits.}; an
author, identified by a name/email address pair; a commit message,
which contains the keyword ``fix''; and a diff, illustrating the lines
that the commit modified. 

First, we would find the commit in Listing~\ref{lst-fix} by searching
the commit logs for the keyword ``fix'', which is indeed a substring
of the commit message, ``I fixed a bug!''.  Next, we would observe
that the commit modifies line 100 of an (unidentified) file---in this
case, the original author used less-than-or-equal (\verb+<=+) instead
of strictly-less-than (\verb+<+), and the commit changes the
comparison operator to the presumably-correct one.  Finally, we
perform a ``git blame'' on this commit, which shows the commit
responsible for the previous version of line 100. Listing
\ref{lst-blame} presents plausible ``git blame'' output, which shows
that the source of the bug fixed in Listing~\ref{lst-fix} is the
commit whose id begins with f4ce718c, as shown in
Listing~\ref{lst-introduction}. We flag this commit as a
bug-introducing commit and store both the bug-introducing
commit f4ce718c and its bug-fixing commit 2cdc03fe in the database.

\begin{lstlisting}[caption=An example bug-fix,label=lst-fix,frame=single]
Commit: 2cdc03fe...
Author: Alice <alice@project.com>
Message: I fixed a bug!
@@ -100,1 +100,1 @@
-    if (i <= 128) {
+    if (i < 128) {
    \end{lstlisting}

    \begin{lstlisting}[caption=Blame of the bug-fix,label=lst-blame,frame=single]
f4ce718c...  100    if (i <= 128) {
    \end{lstlisting}

    \begin{lstlisting}[caption=An example bug-introduction,label=lst-introduction, frame=single]
Commit: f4ce718c...
Author: Bob <bob@project.com>
Message: I hope this works.
@@ -100,0 +100,5 @@
+    if (i <= 128) {
+        do_ascii(i);
+    else {
+        do_unicode(i);
+    }
    \end{lstlisting}

Note that any change in $c$ which removes or modifies an existing line
of code is easy to attribute to a previous commit $c'$, since the
affected line of code existed in $c'$. However, a change in $c$ which
adds a new line of code has no corresponding change in any previous
revision, since this line did not previously exist. In that case, we
attribute responsibility to the commit which introduced the line just
before the new line. This heuristic does not work for bug-introducing
changes in newly-introduced files. Fortunately, such changes are
extremely rare, so we can ignore them entirely.

\paragraph{Data collected}
Executing the above algorithm gives us data about a number of commits
in each repository, as well as about the authors of these commits.  We
record the following data for each commit: author (as a name/email
pair), adjusted time, number of lines changed, and number of times the
commit introduced a bug later corrected (which is derived data; we
record it to simplify later database queries). We also record a
relation connecting bug-introducing commits and bug-fixing
commits. For each author, we record the name, email(s), experience and
classification. We define a bug lifetime's to be the time from the
earliest commit which introduced the bug to the bug-fixing commit.

We compute an author's experience and classification based on the
frequency and duration of that author's commits to a particular
project. Author experience counts the time between an author's
earliest and latest commits to the project. Author classification
describes the author's most-common frequency between consecutive
commits: daily, weekly, monthly, and single. Note that, for author
classification purposes, we ignore consecutive commits within 30
minutes of each other. As a sub-class of the daily commiter
classification, we also use a heuristic to identify commiters who
appear to work on the repository as part of their day job, namely
those for which 85\% of commits are between 8 AM and 4 PM Monday to
Friday.

\paragraph{Time zone adjustments}
All Postgres commits prior to September 18, 2010 (when the project
switched to the Git version control system) contain timestamps in UTC
(Coordinated Universal Time). To enable us to reason about time-of-day
effects for committers, who work in local time zones, we used
publicly-available information (such as the Postgres
contributor-information page, which lists locations for core team
members, and time zones included in mailing list messages) to deduce
time zones for all 34 Postgres committers. We then used the Python
time zone utilities to convert the time for each commit (which was in
UTC for CVS commits, and in local times for git commits) into a local
time for the committer. We assume that the committer is indeed in
our estimated; we discuss this threat to validity in greater detail below.

\paragraph{Threats to Validity}
We discuss a number of threats to validity and how we address them,
including general threats to construct validity and external validity,
and specific threats to our particular methodology, including the
effects of time zones, missing recently-introduced bugs, and
identifying the entire bug-fix processes with the commit times.

A first threat to (construct) validity is that we must properly
identify bug-fixing and bug-introducing commits. To assess this
threat, we estimate the false positive rate by randomly sampling
commits that our analysis identified to be bug fixes and manually
verifying whether or not they are indeed fixes.  We also estimate the
false negative rate by randomly sampling commits identified not to be
bug fixes and manually verifying that these commits are not fixes.

While we believe that the commits from the software that we examined
well represent commits in open source software, we do not intend to
claim external validity and draw any general conclusions about all
software.  Like any other characteristic study, our findings should be
considered together with our evaluation methodology.

We expect our methodology to properly account for developers in
different time zones. Git records each developer's local time (and
time zone) with a commit, thereby avoiding potential imprecisions in
our time-of-day results. This works well for the Linux repository,
which is a native Git repository as of 2005. In that repository, the
local time might be inaccurate if a developer commits from a server in
a different time zone; however, we expect that most of the 8000 Linux
contributors will commit locally on a machine with accurate local
time.  The accuracy of the commit times for the Postgres repository
depends on the accuracy of our time adjustment algorithm for the part
of the history that was originally a CVS history. We believe that
committers don't often change time zones and usually work from their
home time zone, but the validity of our adjustment does depend on the
validity our assumptions about home time zones. We present all of our
results in the local time of the committer.

Because the Postgres repository was converted from CVS to git, the
accuracy of the conversion is another potential threat to validity.  In
particular, CVS does not have a notion of atomic multi-file commits,
while Git does, and our methodology relies on the existence of such
commits. The Postgres conversion used the standard {\tt cvs2git} tool,
with customizations for their particular
repository~\cite{haas09:_so_why_postg_using_git}. We have reason to
believe that the conversion was performed with care, therefore
mitigating threats to validity from repository corruption. Also, note
that the conversion to git obviates the need to identify transactions
from CVS histories, as in~\cite{zimmermann-msr-2004}.

Because our methodology only identifies bugs which have later been
corrected, it will definitely omit recently-introduced bugs, as well
as longer-running bugs which have not yet been corrected. While this
implies that our results will omit some bugs, we do not believe that
this omission affects our validity, because there is no reason to
believe that there are important differences in the characteristics we
measure for fixed and unfixed bugs.

Also, developers work on a patch over a possibly-discontiguous time
interval. However, the code repository only records the endpoint of
that interval.  The bug database may contain more information about
the starting point of the interval (e.g. it records when a bug is
assigned to a developer), but still does not capture any information
about the work patterns of the developer within the interval. There
may be correlations between the coding time (the width of the
interval) and code quality. We intend to investigate these issues in
future work.

Some patches are committed by someone other than the author
of the patch. This occurs especially often for external
contributors. Third-party commits add more uncertainty about when a
patch was originally written, and confound our data about patch
authors.  We believe, however, that it is still reasonable to ascribe
responsibility for the patch to its commiter, who would presumably
have reviewed a patch before committing it.

Finally, we discuss threats to our author classification. Our day-job
classification is based on the somewhat-arbitrary hours of 8AM-4PM.
Although many software companies have flexible hours, we expect that
developers who work on a project as their day job would still have the
bulk of their commits between those hours.  Also, our author
experience information only counts the participation of an author to a
particular project; a highly-experienced developer may be classified
as a newbie developer for one of our projects due to a short history
of contributions to that project. We expect, however, that there is
some value to characterizing authors by their participation in a
single project when analyzing their contributions to that project. It
would be possible to survey developers' participation across multiple
projects by studying the public record, but such a study is beyond the
scope of this paper.
