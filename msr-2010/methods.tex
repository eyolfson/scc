\section{Experimental Methods}
\label{sec:method}
Our goal is to find commits which fix a bug, along with the commits
which introduced that bug. First, we detect a bug-fixing commit $c$ by
searching the commit messages for common keywords such as ``fix'' and
``bug''. Next, we work backwards to locate the commits that introduced
the bug fixed in $c$. Using commit $c$ as a starting point, we compute
a diff for each file between the version after $c$ and the previous
version of that file, and record the line numbers changed in
$c$. Finally, we use the repository metadata to find the commit(s)
$c'$ which were responsible for the previous versions of the files
which were fixed, and we conclude that the commits $c'$ introduced the
bug.

Note that any change in $c$ which removes or modifies an existing line
of code is easy to attribute to a previous commit $c'$, since the
affected line of code existed in $c'$. However, a change in $c$ which
adds a new line of code has no corresponding change in any previous
revision, since this line did not previously exist. In that case, we
attribute responsibility to the commit which introduced the line just
before the new line.

\paragraph{Data collected}
Executing the above algorithm gives us data about each commit, as well
as the authors of the commits\footnote{Name/email.}.  We record the
following data for each commit: author, time, number of lines changed,
and number of times the commit introduced a bug later corrected. For
each author, we record the name, email(s), experience and
classification. We define the bug lifetime as the time from the
earliest commit which introduced a bug to the bug-fixing commit.

We compute an author's experience and classification based on the
frequency and duration of that author's commits to a project. Author
experience counts the time between an author's earliest and latest
commits. Author classification describes the author's most-common
frequency between consecutive commits: daily, weekly, monthly, and
single. Note that, for author classification purposes, we ignore
consecutive commits within 30 minutes of each other. As a sub-class of
the daily commiter classification, we also use a heuristic to identify
commiters who worked on the repository as part of their day job,
namely those for which 85\% of commits are between 8 AM and 4 PM
Monday to Friday.

% maybe move this to the results section
We only considered patches and bugs that are introduced after April 16th, 2005, when
the Linux kernel started to use Git, because the patches before this date do not have 
time information that is accurate to the hour.

\paragraph{Validation}
To validate our data we randomly sample commits then manually verify
that the commit is a bug-fix and that the correct commits introduced
the bug. We focus our manual efforts on changes which include
additions, as conceptually, they are the largest threat to validity.

% Currently there are no false negative rates, we probably have time to sample non fix commits

* time zone information



\paragraph{Threats to Validity}
While we believe that the commits from the examined software well represent commits in 
open source software, we do not intend to draw any general conclusions about
all software. 
Similar to any characteristic study, our
findings should be considered together with our evaluation methodology.

One caveat is that the commits are performed at different time zones as the studied software is 
developed distributed by many developers. If the recorded commit time is for one fixed time zone,
then the time information we collected is imprecise. For example, a Git recorded midnight may be afternoon
for the developer who made the commit. Fortunately, Git records all commits in the developers' local time 
together with the time zone information. Therefore, we used the local time of each commit to collect 
the data shown in this paper. 

As it takes some time for a buggy commit to be discovered, the recent commits that are buggy may not 
have been discovered yet, hence are missing in our statistics. However, as our data are collected over a long period time, 
we expect our data to be representative and the recent commits should exhibit similar characteristics as the rest of the commits. 

The commit time does not necessary correspond to the coding time of a commit. A developer may wait 
for a long time before they commit their code. Studying how coding time correlates with code quality remains as our future work. 
