\section{Results}
\label{sec-results}
In this section, we present the results obtained from carrying out our
methodology, and discuss some of the implications of our results.
Most of our results investigate the effect of an independent variable
(time-of-day and developer experience/frequency classifications) on
the likelihood of a commit to be a bug-introducing commit, or
\emph{bugginess}. We also
describe our findings with respect to the day of the week, which
allows us to compare our results to those
in~\cite{sliwerski-msr-2005}.  Finally, we explain the precision and
recall of our methodology and how we computed these figures.

\paragraph{Project characteristics}
We chose two large open-source software repositories for our
investigations: Linus Torvalds's mainline Linux kernel, from
\url{git.kernel.org} and PostgreSQL, from the project's repository at
\url{git.postgresql.org}. 


Table~\ref{tab:characteristics} summarizes
the characteristics of each of our repositories. 
Row ``bug-introducing'' shows that 23.7-25.5\% of the commits are buggy, which 
is slightly lower than the previously reported nearly 40\% for a commercial switching system~\cite{smallCommits05}. 
%of the samll commits are buggy, this number is on all commits
%in the previous work by Purushothaman and Perry~\cite{smallCommits05}.
Note that the
PostgreSQL repository was carefully converted from CVS using {\code cvs2git} in
September 2010. We discussed some of the quirks of the PostgreSQL repository
in Section~\ref{sec:method}.


\begin{table}
\begin{tabular}{l|r|r}
& {\bf Linux} & {\bf PostgreSQL} \\ \hline
First commit & April 16, 2005 & July 9, 1996 \\
Cloned & November 21, 2010 & January 24, 2011 \\
Lines of code at tip & over 5 million & over 750,000 \\
%Source & \url{git.kernel.org} & \url{git.postgresql.org} \\
Number of authors & 8,594 & 34 \\
Number of commits & 222,332 & 31,098 \\
\# bug-introducing & 56,681 (25.5\%) & 7,366 (23.7\%) \\
\# bug-fixing & \linuxBFC & \postBFC
\end{tabular}
\caption{\label{tab:characteristics}Characteristics of the Linux kernel and PostgreSQL repositories.}
\end{table}

%% The Linux repository
%% was cloned on November 21, 2010, from Linus Torvalds's mainline
%% kernel, hosted at \url{git.kernel.org}; this repository contains
%% history back to April 16, 2005.  This repository contains 222,332
%% commits contributed by 8,594 authors. Of these commits, we identified
%% 56,681 bug-introducing commits and 57,028 bug-fixing commits.
%% The tip of the repository contains
%% over 5 million lines of code. 

%% The PostgreSQL repository was cloned on January 24, 2011, from the
%% project's repository at \url{git.postgresql.org}; it contains history
%% to July 9, 1996, translated from CVS using \code{cvs2git}.  This
%% repository contains 31,098 commits contributed by 34 authors. We
%% identified 7,366 bug-introducing commits and 4,399 bug-fixing commits. The tip
%% of the repository contains over 750,000 lines of code.

\subsection{Time-of-day Results} 
We first present our results correlating the time-of-day of a commit
with its bugginess.  Figures~\ref{fig-linux-bugginess-hour}
and~\ref{fig-postgresql-bugginess-hour} present results from the Linux kernel and
Postgres, respectively. These graphs compare the time-of-day of each
commit, in the committer's local time on a 24-hour clock, to the
percentage of commits which were found to be bug-introducing. The
solid horizontal line indicates the overall percentage number of buggy commits in
each project; bars shorter than the line indicate that commits at that
hour were less likely to be buggy, while bars taller than the line
indicate hours with more-buggy commits. The graphs also contain the
raw number of commits at each hour, as indicated by the red dots.

Both figures show a noticeable increase in the amount of commits which
introduce a bug between 00:00 (midnight) and 04:00 (4AM). After 04:00,
commits tend to be less buggy than average, gradually increasing until
noon.  In the Linux kernel, commits between noon and midnight fluctuate around
the average bugginess level, while the Postgres commits are generally
above the average bugginess level between 16:00 (4PM) and 20:00 (8PM),
and then below the average bugginess level between 20:00 (8PM) and
00:00 (midnight). Note that even the smallest total number of commits,
for any hour, is 139 for Postgres (and an order of magnitude higher
for the Linux kernel), so that all of the depicted bug introduction rates are
meaningful.

Our results suggest that tired developers (midnight-4AM) are more
likely to miss corner cases in a pre-commit review (for Postgres) or
while finalizing the patch (for the Linux kernel). Furthermore, we can observe
that commits before noon are least likely to be bug-introducing;
perhaps committers are most careful in those hours.


\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{linux-bugginess-hour.pdf}
\end{center}
\caption{The Linux kernel percentage of buggy commits (bars) and total number of commits (circles) versus time of day}
\label{fig-linux-bugginess-hour}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{postgresql-bugginess-hour.pdf}
\end{center}
\caption{PostgreSQL percentage of buggy commits (bars) and total number of commits (circles) versus time of day}
\label{fig-postgresql-bugginess-hour}
\end{figure}

%% \begin{figure}
%% \begin{center}
%% \includegraphics[width=0.45\textwidth]{linux_per_class.png}
%% \end{center}
%% \caption{Linux percentage of bug introductions and percentage of total commits per author classification}
%% \label{fig-linux-class}
%% \end{figure}

%% \begin{figure}
%% \begin{center}
%% \includegraphics[width=0.45\textwidth]{firefox_per_class.png}
%% \end{center}
%% \caption{Firefox percentage of bug introductions and percentage of total commits per author classification}
%% \label{fig-firefox-class}
%% \end{figure}

\subsection{Developer Characteristics}
We next present our findings with respect to developers' commiting 
frequency and experience classification. Developers'
commiting frequency summarizes the frequency of
a developer's contributions to a project, while developer experience
tracks how long a developer has contributed to a particular project.

\paragraph{Developers' Committing Frequency Classification} 
As we described in Section~\ref{sec:data}, one of the ways that we
classify developers is according to frequency, i.e. most-common
interval between consecutive commits---daily, weekly, monthly, other,
or single.  This information is only interesting for the Linux kernel, as the
almost all (28/34) of Postgres's committers are daily. We computed the
bugginess rates for each of these classes of developers and plot
author classification versus bug-introduction percentage in
Figure~\ref{fig-linux-bugginess-author-class}. The graph also presents
the number of authors in each class; the Linux kernel has 49 day job authors,
and 238 weekly and 288 monthly authors.

Our results show that the Linux kernel developers who commit changes daily, but
not as their day job, produce the smallest number of bug-introducing
commits, followed by the single-commit authors (whose patches would
presumably be simple or closely-reviewed). The day job, weekly, and
monthly committers all produce slightly more bug-introducing commits
than average.

A possible cause for the difference between day-job and daily
committers is that day-job developers might be required to make
changes by their employers, while the daily developers are motivated
purely by interest, and unlikely to be pressured to fix bugs on any
particular schedule.

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{linux-bugginess-author-class.pdf}
\end{center}
\caption{Linux percentage of buggy commits (bars) and number of authors (circles) versus author classification}
\label{fig-linux-bugginess-author-class}
\end{figure}

% we need to say what the two bars mean in the figure.

%% \begin{figure}
%% \begin{center}
%% \includegraphics[width=0.45\textwidth]{linux_day_per_experience.png}
%% \end{center}
%% \caption{Linux percentage of bug introductions and percentage of total commits per author experience}
%% \label{fig-linux-experience}
%% \end{figure}

%% \begin{figure}
%% \begin{center}
%% \includegraphics[width=0.45\textwidth]{firefox_day_per_experience.png}
%% \end{center}
%% \caption{Firefox percentage of bug introductions and percentage of total commits per author experience}
%% \label{fig-firefox-experience}
%% \end{figure}

\paragraph{Developer Experience Classification}
The final head-to-head comparison we performed is based on the amount
of experience per author. We divided them up into 6-month intervals. 
Our results from the Linux kernel and PostgreSQL are shown in Figure~\ref{fig-linux-bugginess-experience} and Figure~\ref{fig-postgresql-bugginess-experience}
respectfully. For the Linux kernel authors with less than 2 years of experience
are more likely to commit a bug while after 2 years the likelihood
decreases. However the authors which committed throughout the history
of the project are more likely to commit a bug which may be because
they wrote the majority of the code. %% For Firefox, again the
%% developers with less than 6 months of experience are more likely to
%% commit a bug. The is a spike between 21 and 26 months as well. We
%% believe these results may not be accurate due to the possiblity of
%% our experience metric being crude and not representative of the 
%% actual experience with the project.

%% \begin{figure}
%% \begin{center}
%% \includegraphics[width=0.45\textwidth]{linux_bug_life.png}
%% \end{center}
%% \caption{Linux number of bugs against bug lifetimes in months}
%% \label{fig-linux-buglife}
%% \end{figure}

%% \begin{figure}
%% \begin{center}
%% \includegraphics[width=0.45\textwidth]{firefox_bug_life.png}
%% \end{center}
%% \caption{Firefox number of bugs against bug lifetimes in months}
%% \label{fig-firefox-buglife}
%% \end{figure}

Finally we determined the bug lifetimes for both projects to contrast
them to previous work. We plotted the number of bugs for each lifetime
divided into 4 month intervals. The results for the Linux kernel are shown in
Figure~\ref{fig-linux-bug-lifetime}, the average bug lifetime is 1.39
years. The results for Firefox are shown in Figure~\ref{fig-postgresql-bug-lifetime}, with an average bug lifetime of 0.97
years. This shows a reduction in the average bug lifetime for the Linux kernel (in
2002 the average lifetime was 1.8 years). This indicates that
developers are improving as their development process becomes more
refined. We also see the average lifetime is lower for Firefox, this
may be due to the complexity of the software, size of the software or
the amount of users (the more users and complex, the more likely bugs will be
revealed).

%% \begin{figure}
%% \begin{center}
%% \includegraphics[width=0.45\textwidth]{postgresql-bugginess-author-class.pdf}
%% \end{center}
%% \caption{PostgreSQL percentage of buggy commits per author classification}
%% \label{fig-postgresql-bugginess-author-class}
%% \end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{linux-bugginess-experience.pdf}
\end{center}
\caption{The Linux kernel percentage of buggy commits per author experience}
\label{fig-linux-bugginess-experience}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{postgresql-bugginess-experience.pdf}
\end{center}
\caption{PostgreSQL percentage of buggy commits per author experience}
\label{fig-postgresql-bugginess-experience}
\end{figure}


\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{linux-introductions-day.pdf}
\end{center}
\caption{The Linux kernel introductions per commit per day}
\label{fig-linux-introductions-day}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{postgresql-introductions-day.pdf}
\end{center}
\caption{PostgreSQL introductions per commit per day}
\label{fig-postgresql-introductions-day}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{linux-severity-day.pdf}
\end{center}
\caption{The Linux kernel severity of changes per day}
\label{fig-linux-severity-day}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{postgresql-severity-day.pdf}
\end{center}
\caption{PostgreSQL severity of changes per day}
\label{fig-postgresql-severity-day}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{linux-introductions-hour.pdf}
\end{center}
\caption{The Linux kernel introductions per commit per hour}
\label{fig-linux-introductions-hour}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{postgresql-introductions-hour.pdf}
\end{center}
\caption{PostgreSQL introductions per commit per hour}
\label{fig-postgresql-introductions-hour}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{linux-severity-hour.pdf}
\end{center}
\caption{The Linux kernel severity of changes per hour}
\label{fig-linux-severity-hour}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{postgresql-severity-hour.pdf}
\end{center}
\caption{PostgreSQL severity of changes per hour}
\label{fig-postgresql-severity-hour}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{linux-bugginess-day.pdf}
\end{center}
\caption{The Linux kernel percentage of buggy commits per day}
\label{fig-linux-bugginess-day}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{postgresql-bugginess-day.pdf}
\end{center}
\caption{PostgreSQL percentage of buggy commits per day}
\label{fig-postgresql-bugginess-day}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{linux-bug-lifetime.pdf}
\end{center}
\caption{The Linux kernel bug lifetime}
\label{fig-linux-bug-lifetime}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\columnwidth]{postgresql-bug-lifetime.pdf}
\end{center}
\caption{PostgreSQL bug lifetime}
\label{fig-postgresql-bug-lifetime}
\end{figure}


\subsection{Day-of-week Results} Having determined our false positive rate, 
we continue by presenting the results of our analysis.  First, we
determine if the day of the week has any impact on the likelihood of
producing bugs. For the following graphs, the percentage of
introduction commits indicates the amount of commits which are bug
introductions, as a propostion of the total number of
commits. Figure~\ref{fig-linux-bugginess-day} presents our results for
the Linux kernel. We see that Saturday is the worst day, followed by Thursday,
while Monday has the fewest percentage of bug introductions. The
results for PostgreSQL are shown in Figure~\ref{fig-postgresql-bugginess-day} and
agree with Thursday being one of the worst days, while Monday is the
best day for committing changes which do not introduce bugs. A
possible explanation is that developers rest over the weekend and have
ample time to think about the problem before coding a solution on
Monday, when they know exactly what to do. Per-day bugginess may also
be correlated with the size of the change, which we plan to investigate
later, as an addition to our technique.

\subsection{Bug lifetimes}

\subsection{Comment-only Commits}
We noticed a large number of bug-fixing commits in the database
reported 0 lines changed. We performed a random sample on 50 of these
commits for each project and found most only changed comments in the
source code. For the Linux kernel 2.15~$\pm$~0.10\% of the bug-fixing
commits were on comments. We followed the same procedure for
PostgreSQL and found 2.97~$\pm$~0.45\% of bug-fixing commits were on
comments.

%% We also noted that approximately 7.7\% of the bug fixes for Linux were
%% purely for comments, indicating that developers spend a non-trivial
%% amount of time on comments. For Linux, approximately 51\% of the
%% changes do not include additions. We therefore manually checked (a
%% subsample of) the 49\% more difficult cases to evaluate the
%% effectiveness of our heuristic for additions.

\subsection{Validation} 
To validate our results, we estimated the precision and recall of our
technique for identifying bug-fixing commits on both projects.  As our
algorithm for identifying the associated bug-introducing commits was a
straightforward application of git blame, we did not systematically
verify its performance. (A brief manual inspection of bug-introducing
commits did not reveal any anomalies.) 
For both projects, we randomly sampled 50 bugs
from each of the population of commits that we identified to be
bug-fixing commits, BI (to evaluate precision).
%, and commits that we
%identified to be non-bug-fixing commits, $\neg$ BI (to evaluate recall).
Table~\ref{tab:pr-raw} summarizes our precision findings.
%and
%recall findings.

We evaluated the precision---that is, the proportion of identified
bug-fixing commits which do indeed fix bugs---and found that, for
the Linux kernel, 43 of the 50 bugs (in BI) that we automatically identified as
bug-fixing commits did indeed fix bugs, while 7 did not; for Postgres,
42 of 50 identified fixes (BI) were indeed fixes.  Some of the
cases included: 1) a commit message which fixed a merge commit was
classified as a fix; 2) apparently garbled commit messages which
included the keyword ``fix'' for no good reason; 3) changes which were
reverted (in the alleged ``fix'') but then re-added in a later
version; 4) poor uses of version control systems which included many
different changes in a single commit, including a fix as a small part 
of the commit; and 5) refactoring changes, which moved or renamed
functions---these could arguably be considered to be fixes to a buggy
initial design.

We have estimated our recall---the proportion of bug-fixing commits in
the entire sample that our technique identifies---to be at least \linuxR for
Linux and \postR for Postgres, and we are certain that our sampling
technique underestimates the recall. We intend to re-evaluate the
recall of our technique in the near future.

%% To evaluate the recall of our technique---the proportion of bug-fixing
%% commits in the entire sample that we manage to identify---we sampled
%% 50 non-bug-introducing commits from both the Linux kernel and
%% Postgres. Table~\ref{tab:pr-raw} presents the raw recall data. To compute
%% the recall, we evaluate
%% \[ \mbox{Recall} = \frac{\mbox{identified BI} \cap \mbox{actual BI}}{\mbox{identified BI}}; \]
%% however, to do so, we must normalize the number of identified bug-introducing
%% commits. Based on the precision results, we know that there are at least
%% 48745 bug-introducing commits, so we should have sampled 
%% Table~\ref{tab:pr-raw} therefore also shows our adjusted data in 
%% brackets.

\begin{table}
\begin{center}
\begin{tabular}{rrr}
Linux & actual BI & actual $\neg$ BI \\
identified BI & 43 & 7 \\
%identified $\neg$ BI & 6 (23) & 44 (172) \\
\end{tabular} 

\begin{tabular}{rrr} Postgres & actual BI & actual $\neg$ BI \\
identified BI & 42 & 8 \\
%identified $\neg$ BI & 3 (21) & 47 (332)
\end{tabular}
\end{center}
\caption{\label{tab:pr-raw}Raw results for precision.}

%% \begin{center}
%% \begin{tabular}{rrr}
%% Linux & actual BI & actual $\neg$ BI \\
%% identified BI & 43 & 7 \\
%% identified $\neg$ BI & 23 & 172 \\
%% \end{tabular} 

%% \begin{tabular}{rrr} Postgres & actual BI & actual $\neg$ BI \\
%% identified BI & 42 & 8 \\
%% identified $\neg$ BI & 21 & 332
%% \end{tabular}
%% \end{center}
%% \caption{\label{tab:pr-adj}Adjusted results for precision and recall.}
\end{table}


