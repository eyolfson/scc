\section{Idea \& Approach}
\label{sec-idea}

At the start of our research, we collected data manually from the
Linux kernel repository using {\em git}. We examined logs for bug
fixes, and traced back the bug-inducing changes to a specific user and
time. This preliminary data was to be used for verifying the
correctness of our automatically collected data and also give
us an idea of what kind of results to expect.

Our solution attempts to find as many factors as possible that could
potentially contribute to the introduction of bugs. This includes
considering commit times of the changes as well as the authors making
those changes. The goal is to find any meaningful correlations, and deduce
recommendations to reduce the negative effects on bug introduction in
the code. We built a database with all of the information that we have
collected in order to easily extract data. Other researchers would also
be able to use our data and find more correlations.

The two software projects we chose to start investigating are the Linux kernel and
Firefox browser. Some of the questions we try to answer are:
\begin{itemize}
\item
Is there a correlation between the time of day a commit is made and the number 
of bugs introduced?
\item
Is there a correlation between the classification of the user and the number 
of bugs introduced by the user?
\item
Are less experienced developers more prone to introducing bugs? (Light users will
be considered less experienced)
\item
Is here a correlation between the day of the week and the number of bugs
introduced by the users?
\item
Is there an improvement in the average bug lifetime? How is it distributed?
\end{itemize}

We intend to answer the questions posed above by looking at the code
fixes and finding which commit caused the bug. The commits are
gathered from the software repository, which in the case of Linux is
git and for Firefox we converted the mercurial repository to git for
ease of implementation. These contain the author and the time of the
day the change was made, their time zone offset, and of course the
actual change. We added this information to the database for future
reference. The use of a database should be beneficial in the future
for others to write queries and find data of interest to them, without
having to go through the hassle of manually examining the software's
repository. We also went through all of the commits and added more
entries to the database which record the commits by each user.  We
then used this information to classify users into one of the following
classifications: daily, weekly, monthly, or single committer.

We started off by manually reading the bug fixes and tracing them back
to their source. After we have obtained enough experience doing this
and have a collection of known bug introductions, we started to
automate the process of extracting bug-inducing changes. We validated
our data by randomly sampling automatically generated bug
introductions and verifying them by hand to judge our technique.

After we constructed our database we wrote queries to answer the questions
outlined previously. We then tried to explain some of these
correlations and suggest some reasons as to why the bugs were introduced (this
is detailed in the conclusion).

\section{Implementation}
\label{sec-impl}

We demonstrate our technique on a simple example, for instance say
there is a change in the code repository such as the one in Listing
\ref{lst-introduction}. The listings contain a {\em unified diff}
between the current version in the commit and the previous version,
which is what we use in our tool. The bug here is that when {\em i} is
equal to 256 the code should actually use the {\em do\_unicode}
function. A commit which fixes this bug is shown in Listing \ref{lst-fix}.

\newpage

\begin{lstlisting}[caption=An example bug introduction,label=lst-introduction, frame=single]
Commit: f4ce718c...
Message: I hope this works.
@@ -100,0 +100,5 @@
+    if (i <= 256) {
+        do_ascii(i);
+    else {
+        do_unicode(i);
+    }
\end{lstlisting}

\begin{lstlisting}[caption=An example bug fix,label=lst-fix,frame=single]
Commit: 2cdc03fe...
Message: I fixed a bug!
@@ -100,1 +100,1 @@
-    if (i <= 256) {
+    if (i < 256) {
\end{lstlisting}

Our goal is to be able to find the commit which introduced the bug and
also link it to the commit which included the fix. We found most
developers indicate that their change is a fix by including the keyword "fix"
in the commit message. We perform a simple keyword search with the word "fix"
to find these commits. For this example we should find the commit
starting with 2cdc03fe. From the unified diff we know line 100 was
modified from the previous version on line 100. We then perform a {\em
  git-blame} on the previous version which indicates the last commit
which changed the line. The output of the blame is shown in Listing
\ref{lst-blame}

\begin{lstlisting}[caption=Blame of the previous version,label=lst-blame,frame=single]
f4ce718c...  100    if (i <= 256) {
\end{lstlisting}

Using the blame information we found the original commit which
introduced the bug, and can enter it into our database. This
technique of blaming can be used for any modifications or removals
easily, however additions pose a problem as the previous file gives us
no information. In the case of additions we perform a blame on the
current version of the file, we use the commit which modified the line
before the new block of code as the commit which introduced the
bug. In most cases the fix adds error checking code the original
author forgot about.

We also take precautions when we analyze the changes. First we only
look at changes which happen to C/C++ code. We ignore all comments as
well since we are concerned solely about code changes. Finally, we
ignore whitespace when performing the blaming so we do not create a
false introduction point from a change that didn't actually change the
code.

Our process is automated using Python scripts which we wrote. We used
bindings for git along with a diff library to interact with the code
repository. We populate a MySQL database with the information we
collect. A high level version of our database schema is shown in
Listing \ref{lst-core}.

\begin{lstlisting}[caption=Core database schema,label=lst-core,frame=single]
class Repository:
    name = CharField()
    description = TextField()

class Author:
    repository = 
        ForeignKey(Repository)
    name = CharField()
    email = CharField()

class Commit:
    author =
        models.ForeignKey(Author)
    sha1 = models.CharField()
    utc_time = models.DateTimeField()
    local_time =
        models.DateTimeField()

class Bug:
    introductions =
        ManyToManyField(Commit)
    fixes = ManyToManyField(Commit)    
\end{lstlisting}

We also provided an extension to the database as an example of what
can be done with the core data. Our extension for author information
is shown in Listing \ref{lst-extension}. To classify each author we
can perform the following steps: sort their commits by time, look at
the time difference between consecutive commits (ignoring changes less
than 30 minutes apart) and record the time difference as
daily/weekly/monthly. We then classify them based on what time
difference is between the majority of their commits. We also have an
additional check for daily committers, if 85\% of their commits are
between 8 AM - 4 PM Monday to Friday we also classify them as having a
day job on the project. Finally we determine how many months of
experience they have by looking at the time difference from their
first commit to last commit.

\begin{lstlisting}[caption=Extension to database schema,label=lst-extension,frame=single]
class AuthorInformation:
    CLASSIFICATIONS = (
        ('D', 'Daily'),
        ('W', 'Weekly'),
        ('M', 'Monthly'),
        ('S', 'Single'),
    )
    author = ForeignKey(Author)
    classification = CharField(
        choices=CLASSIFICATIONS)
    day_job = BooleanField()
    experience = IntegerField()    
\end{lstlisting}

